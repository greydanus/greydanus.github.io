---
layout: post
comments: true
title:  "Jumpy Recurrent Neural Networks"
excerpt: "We propose a Jumpy RNN model which can jump over long durations of uniform change in order to focus on pivotal events."
date:   2020-10-15 11:00:00
mathjax: true
author: Sam Greydanus, Stefan Lee, and Alan Fern
thumbnail: /assets/jumpy-rnn/thumbnail.png
---

<div>
	<style>
		#linkbutton:link, #linkbutton:visited {
		  background-color: rgb(180,180,180);
		  border-radius: 4px;
		  color: white;
		  padding: 6px 0px;
		  width: 150px;
		  text-align: center;
		  text-decoration: none;
		  display: inline-block;
		  text-transform: uppercase;
		  font-size: 13px;
		  margin: 8px;
		}

		#linkbutton:hover, #linkbutton:active {
		  background-color: rgba(160,160,160);
		}

		.playbutton {
		  background-color: rgb(148, 196, 146);
		  border-width: 0;
		  /*background-color: rgba(255, 130, 0);*/
		  border-radius: 4px;
		  color: white;
		  padding: 5px 8px;
		  /*width: 60px;*/
		  text-align: center;
		  text-decoration: none;
		  text-transform: uppercase;
		  font-size: 12px;
		  /*display: block;*/
		  /*margin-left: auto;*/
		  margin: 8px 0px;
		  margin-right: auto;
		  min-width:60px;
		}

		.playbutton:hover, .playbutton:active {
		  background-color: rgb(128, 176, 126);
		}
	</style>
</div>

<div class="imgcap" style="display: block; margin-left: auto; margin-right: auto; width:99.9%">
  <div style="width:32%; min-width:250px; display: inline-block; vertical-align: top;text-align:center;padding-right:10px;">
    <video id="video_sim" style="width:100%;min-width:250px;">
    	<source src="/assets/jumpy-rnn/video_simulator.mp4" type="video/mp4">
    </video>
    <button class="playbutton" id="video_sim_button" onclick="playPauseSim()">Play</button> 
    <div style="text-align: left;margin-left:10px;margin-right:10px;">Using model-based planning to play pool/billiards. The goal is to impart the tan cue ball with an initial velocity so as to move the blue ball to the black target.</div>
  </div>
  <div style="width:32%; min-width:250px; display: inline-block; vertical-align: top;text-align:center;padding-right:10px;">
    <video id="video_base" style="width:100%;min-width:250px;">
    	<source src="/assets/jumpy-rnn/video_base.mp4" type="video/mp4">
    </video>
    <button class="playbutton" id="video_base_button" onclick="playPauseBase()">Play</button> 
    <div style="text-align:left;margin-left:10px;margin-right:10px;">A baseline RNN trained on billiards dynamics can also be used for model-based planning. It's inefficient because it has to "tick" at a constant rate.</div>
  </div>
   <div style="width:32%; min-width:250px; display: inline-block; vertical-align: top;text-align:center;">
    <video id="video_jumpy" style="width:100%;min-width:250px;">
    	<source src="/assets/jumpy-rnn/video_jumpy.mp4" type="video/mp4">
    </video>
    <button class="playbutton" id="video_jumpy_button" onclick="playPauseJumpy()">Play</button> 
    <div style="text-align:left;margin-left:10px;margin-right:10px;">By contrast, a Jumpy RNN trained on the same task can perform planning in many fewer steps by jumping over spans of time where motion is predictable.</div>
  </div>
</div>

<script> 
function playPauseSim() { 
  var video = document.getElementById("video_sim"); 
  var button = document.getElementById("video_sim_button");
  if (video.paused) {
    video.play();
	button.textContent = "Pause";}
  else {
    video.pause(); 
	button.textContent = "Play";}
} 

function playPauseBase() { 
  var video = document.getElementById("video_base"); 
  var button = document.getElementById("video_base_button");
  if (video.paused) {
    video.play();
	button.textContent = "Pause";}
  else {
    video.pause(); 
	button.textContent = "Play";}
} 

function playPauseJumpy() { 
  var video = document.getElementById("video_jumpy"); 
  var button = document.getElementById("video_jumpy_button");
  if (video.paused) {
    video.play();
	button.textContent = "Pause";}
  else {
    video.pause(); 
	button.textContent = "Play";}
} 
</script>

<div style="display: block; margin-left: auto; margin-right: auto; width:100%; text-align:center;">
	<a href="https://openreview.net/pdf?id=4c3WeBTErrE" id="linkbutton" target="_blank">Read the paper</a>
	<a href="" id="linkbutton" target="_blank">Run in browser</a>
	<a href="https://github.com/greydanus" id="linkbutton" target="_blank">Get the code</a>
</div>

## Change, it is said, happens slowly and then all at once...

<!-- Change, it is said, happens slowly and then all at once. -->
Billiards balls move across a table before colliding and changing trajectories; water molecules cool slowly and then undergo a rapid phase transition into ice; and economic systems enjoy periods of stability interspersed with abrupt market downturns. That is to say, many time series exhibit periods of relatively homogeneous change divided by important events. Despite this, recurrent neural networks (RNNs) -- a popular type of time series model -- treat time in uniform intervals. In doing so, they are forced to spend much of their time stepping through periods of relatively predictable change.

In this post, I will introduce a simple RNN variant that can jump over long time intervals while retaining the ability to produce fine-grained updates when necessary. This “Jumpy RNN” model can make predictions that are either one second in the future or twenty seconds in the future depending on the context.

Whereas most RNNs maintain a hidden state which summarizes their belief about where they are in the world, our model maintains both a hidden state \\(h\\) _and_ a hidden velocity \\(\dot h\\). Then, by assuming that the hidden state changes linearly over a certain duration of time, we can predict any state within that duration by multiplying the hidden velocity by change in time and adding it to the hidden state: \\(h(t) = h + \dot h \Delta t\\). In effect, this new model now _predicts a sequence of linear dynamics functions and durations over which they are valid_. By doing so, it can summarize a long span of homogeneous change in one go. Alternatively, it can break that span into smaller bits in order to improve accuracy.

<div class="imgcap_noborder" style="display: block; margin-left: auto; margin-right: auto; width:100%; min-width: 300px">
  <img src="/assets/jumpy-rnn/hero.png" style="width:100%">
</div>

In order to compare our model to regular RNNs, we used both of them to model a series of simple physics problems including the collisions of two pool/billiards balls. We found that our jumpy model was able to learn these patterns at least as well as the baseline while using a fraction of the forward simulation steps. This makes it a great candidate for model-based planning because it can predict the outcome of taking an action much more quickly than a baseline model. And since the hidden-state dynamics are continuous in time, we can solve for the hidden state at any arbitrary point in time. This allows us to simulate the dynamics of, say, billiards, at a higher temporal resolution than the original simulator:

<div class="imgcap" style="display: block; margin-left: auto; margin-right: auto; width:99.9%">
  <div style="width:32%; min-width:250px; display: inline-block; vertical-align: top;text-align:center;padding-right:10px;">
    <video id="video_jumpy2" style="width:100%;min-width:250px;">
    	<source src="/assets/jumpy-rnn/video_jumpy.mp4" type="video/mp4">
    </video>
    <button class="playbutton" id="video_jumpy2_button" onclick="playPauseJumpy2()">Play</button> 
    <div style="text-align:left;margin-left:10px;margin-right:10px;">Using a Jumpy RNN to predict the same trajectory.</div>
  </div>
  <div style="width:32%; min-width:250px; display: inline-block; vertical-align: top;text-align:center;">
    <video id="video_interp" style="width:100%;min-width:250px;">
    	<source src="/assets/jumpy-rnn/video_interp.mp4" type="video/mp4">
    </video>
    <button class="playbutton" id="video_interp_button" onclick="playPauseInterp()">Play</button> 
    <div style="text-align:left;margin-left:10px;">By interpolating between hidden states predicted by the Jumpy RNN, we can obtain dynamics at a higher temporal resolution than that of the original simulator.</div>
  </div>
</div>

<script> 
function playPauseSim2() { 
  var video = document.getElementById("video_sim2"); 
  var button = document.getElementById("video_sim2_button");
  if (video.paused) {
    video.play();
	button.textContent = "Pause";}
  else {
    video.pause(); 
	button.textContent = "Play";}
} 

function playPauseJumpy2() { 
  var video = document.getElementById("video_jumpy2"); 
  var button = document.getElementById("video_jumpy2_button");
  if (video.paused) {
    video.play();
	button.textContent = "Pause";}
  else {
    video.pause(); 
	button.textContent = "Play";}
} 

function playPauseInterp() { 
  var video = document.getElementById("video_interp"); 
  var button = document.getElementById("video_interp_button");
  if (video.paused) {
    video.play();
	button.textContent = "Pause";}
  else {
    video.pause(); 
	button.textContent = "Play";}
} 
</script>

In summary, Jumpy RNNs represent an important improvement over regular RNNs for several important reasons. But before we discuss those reasons, we need to begin by talking about what regular RNNs are good at, and why they are worth improving upon.

## The Value of RNNs

Recurrent neural networks are interesting because they can learn complex, long-range structure in time series data simply by predicting one point at a time. For example, if you train them on sequences of words, you can use them to translate from one language to another, or to generate possible completions to a prompt. And if you train them on observations of a robot arm, you can use them to generate realistic paths that the arm might take in the future. One of the things that makes these models so flexible is that they use a hidden vector _h_ to store memories of past observations. And they can _learn_ to read, write, and erase information from h in order to make accurate predictions about the future. This means that RNNs are quite good (although simplistic) models for how brains learn to use memory for such things. Here is an incomplete list of things people have trained RNNs to do:
* •\\(~~\\)Translate text from one language to another (think Google Translate)
* •\\(~~\\)Control a robot hand in order to solve a Rubik’s Cube
* •\\(~~\\)Defeat professional human gamers in StarCraft
* •\\(~~\\)Caption images
* •\\(~~\\)Generate realistic handwriting
* •\\(~~\\)Convert text to speech
* •\\(~~\\)Convert speech to text
* •\\(~~\\)Compose simple songs
* •\\(~~\\)...and much more


## The Limitations of RNNs

**Uniform ticks.** I’ve been interested in RNNs for a long time, but one aspect of their design has always bothered me: they can only tick at one uniform rate, sort of like a clock. At each tick they make one observation of the world, perform one read-erase-write on their memory, and send one output message. This seems too rigid. We wouldn’t open our eyes, close them, think, then act, and repeat. This would be silly because sometimes we need to think fast and other times we need to think slow. For us, time is a very dynamic thing.

One of the great things about being able to think in this manner is that it helps us plan. For example, we can jump to three months in the future when we will be traveling to another country, realize that we’ll need our passport updated, and then make a short-term plan for how to do that. Our short-term plan might be: stop at the Post Office to get passport photos after work. And in order to pay for those photos, grab some extra cash from the piggy bank. And so the simple act of putting a $20 bill in our wallets can have many layers of planning behind it. What's more is that planning is happening across many time scales. Our brain does this by jumping from one event to another without thinking much about the intervening duration, and this is something that models like RNNs aren’t great at doing.

**Discrete time steps.** Another issue with RNNs is that they perceive time as a series of discrete “time steps” that connect neighboring states. Since time is actually a continuous variable -- it has a definite value even in between RNN ticks -- we really should use models that treat it as such. In other words, when we ask our model what the world looked like at time \\( t=1.42\\) seconds, it should not have to locate the two ticks that are nearest in time and then interpolate between them, as is the case with RNNs. Rather, it should be able to give a well-defined answer. Models like Neural ODEs (which are closely related to this work) take a step in this direction, but it’s still an underexplored area of research.


## Our Results

Our work on Jumpy RNNs was an attempt to fix these issues. Our model can jump over different durations of time and this allows it to tick more often when a lot is happening and less often otherwise. As we explained in the introduction, Jumpy RNNs are different from regular RNNs in that they predict a hidden state velocity in addition to a hidden state. Taken together, these two quantities represent a linear dynamics function in the RNN’s latent space. A second modification we make is to have the model predict the duration of time \\(\Delta t\\) over which that dynamics function is valid. In some cases, when change is happening at a constant rate, this value can be quite large. For example, when we create a toy dataset of perfectly linear motion, our model learns to summarize the trajectory in a single step.

<div class="imgcap_noborder" style="display: block; margin-left: auto; margin-right: auto; width:100%; min-width: 300px">
  <img src="/assets/jumpy-rnn/lines.png" style="width:100%">
</div>

It’s worth noting that the way a system changes in time is only linear with respect to a particular coordinate system. For example, an object undergoing constant circular motion has nonlinear dynamics when we use Cartesian coordinates, but linear dynamics when we use Polar coordinates. That’s why physicists use different coordinates to describe different physical systems: the best coordinates are those that are maximally linear with respect to the dynamics.

Since a Jumpy RNN forces dynamics to be linear in latent space, the encoder and decoder layers naturally learn to transform input data into a basis where the dynamics are linear. For example, when we train our model on a dataset of circular trajectories represented in Cartesian coordinates, it learns to summarize such trajectories in a single step as well. This implies that circular motion is linear in the model’s latent space, and that it has effectively learned a Cartesian-to-Polar conversion.

<div class="imgcap_noborder" style="display: block; margin-left: auto; margin-right: auto; width:100%; min-width: 300px">
  <img src="/assets/jumpy-rnn/circles.png" style="width:100%">
</div>

Our model can learn more complicated change-of-basis functions as well. Later in the paper, we trained our model on pixel observations of two billiards balls. The pixel “coordinate system” is extremely nonlinear with respect to the linear motion of the two balls. And yet our model was able to predict the dynamics of the system _more effectively_ than the baseline model using three times fewer “ticks.” This jumpiness implies that our model found a basis in which the billiards dynamics were linear for significant durations of time -- something that would never happen in a pixel basis.

<div class="imgcap_noborder" style="display: block; margin-left: auto; margin-right: auto; width:100%; min-width: 300px">
  <img src="/assets/jumpy-rnn/pixel_billiards.png" style="width:100%">
</div>

In fact, we suspect that forcing dynamics to be linear in latent space actually _biased_ our model to find linear dynamics. We hypothesize that the baseline model performed worse on this task because it had no such inductive bias.



## Planning

One of the reasons we originally set out to build a Jumpy RNN was that we wanted to use it for planning. We were struck by the fact that many events one would want to plan over -- collisions, in the case of billiards -- are separated by variable durations of time. We suspected that a jumpy model would be particularly effective at planning in such scenarios.

In order to test this hypothesis, we tested our model against a baseline RNN on a simple planning task in the billiards environment. The goal was to impart one ball, the “cue ball” (visualized in tan) with an initial velocity such that it would collide with the second ball and the second ball would ultimately enter a target region (visualized in black).

We found that our model used half the wall time of the baseline and produced plans with a higher probability of success. These results are preliminary -- and part of ongoing work -- but they do confirm our hypothesis that the jumpy model would be useful for model-based planning.


## Related Work

**Other continuous-time models.** One challenge in training neural ODEs is that they must be continuously solved even when no observations occur, making forward passes take 60\% - 120\% longer than standard RNNs \citep{rubanova2019latent}. Since the integration speed of a Neural ODE is proportional to the curvature of the hidden state dynamics (higher curvature requires more steps), one can improve speed and efficiency by regularizing that curvature. \cite{finlay2020train} take a step in this direction. Even so, the number of time steps per function evaluation tends to be less than one. Our model resembles Neural ODEs in that it parameterizes the derivative of a hidden state. However, we make the simplifying assumption that the hidden state dynamics are linear for long stretches of time. This makes our model extremely efficient to integrate over long spans of time -- more efficient, in fact, than a baseline RNN. This jumpy behavior is what our model is designed for, and where it excels compared to Neural ODEs.

**Other approaches to temporal abstraction.** There are other RNN-based models designed with temporal abstraction in mind. \cite{koutnik2014clockwork} proposed dividing an RNN internal state into groups and only performing cell updates on the $i^{th}$ group after $2^{i-1}$ time steps. More recent works have aimed to make this hierarchical structure more adaptive, either by data-specific rules \citep{ling2015character} or by a learning  mechanism \citep{chung2019hierarchical}. All of these hierarchical recurrent models can model data at different timescales, but they all \textit{must} perform cell updates at every time step in a sequence, and hence cannot jump over regions of homogeneous change.

Recent work by \cite{gregor2018temporal} in the context of reinforcement learning develops a jumpy planning model which does not use an RNN cell or perform continuous interpolation of latent states. Another relevant work in the field of RL is Embed to Control by \cite{watter2015embed}. Their work is similar to ours in that they assume that dynamics are linear in latent space and they train their model on several dynamics problems, some of them with pixel observations. But unlike our work, their model performs inference over discrete, uniform time steps and does not learn a jumpy behavior.


## Conclusions

Having achieved widespread use in commercial and academic settings, RNNs are already a useful tool. But even though they are useful tools, they still have fundamental limitations. In this paper, we reckoned with the fact that they can only forecast the future in discrete, uniform time steps. In order to make RNNs more useful in more contexts, it is essential to find solutions to such restrictions. With this in mind, we proposed a Jumpy RNN model which can skip over long durations of comparatively homogeneous change and focus on pivotal events as the need arises. We hope that this line of work will expand the possible uses of RNNs and make them capable of representing time in a more efficient and flexible manner.

## Footnotes

[^fn1]: Note: the code and overall approach to optimizing a wing in a fluid simulation is built on [this Autograd example](https://github.com/HIPS/autograd/blob/master/examples/fluidsim/wing.png).